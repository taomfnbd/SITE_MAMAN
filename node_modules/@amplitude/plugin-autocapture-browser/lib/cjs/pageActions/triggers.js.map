{"version":3,"file":"triggers.js","sourceRoot":"","sources":["../../../src/pageActions/triggers.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ElementInteractionsOptions, LabeledEvent, Trigger } from '@amplitude/analytics-core';\nimport type { ElementBasedTimestampedEvent, ElementBasedEvent } from 'src/helpers';\nimport { matchEventToFilter } from './matchEventToFilter';\nimport { executeActions } from './actions';\nimport type { DataExtractor } from '../data-extractor';\n\nconst eventTypeToBrowserEventMap = {\n  '[Amplitude] Element Clicked': 'click',\n  '[Amplitude] Element Changed': 'change',\n} as const;\n// groups labeled events by event type\n// skips any labeled events with malformed definitions or unexpected event_type\nexport const groupLabeledEventIdsByEventType = (labeledEvents: LabeledEvent[] | null | undefined) => {\n  // Initialize all event types with empty sets\n  const groupedLabeledEvents = Object.values(eventTypeToBrowserEventMap).reduce((acc, browserEvent) => {\n    acc[browserEvent] = new Set<string>();\n    return acc;\n  }, {} as Record<string, Set<string>>);\n\n  // If there are no labeled events, return the initialized groupedLabeledEvents\n  if (!labeledEvents) {\n    return groupedLabeledEvents;\n  }\n\n  // Group labeled events by event type\n  for (const le of labeledEvents) {\n    try {\n      for (const def of le.definition) {\n        const browserEvent = eventTypeToBrowserEventMap[def.event_type];\n        if (browserEvent) {\n          groupedLabeledEvents[browserEvent].add(le.id);\n        }\n      }\n    } catch (e) {\n      // Skip this labeled event if there is an error\n      console.warn('Skipping Labeled Event due to malformed definition', le?.id, e);\n    }\n  }\n  return groupedLabeledEvents;\n};\n\n// TODO: add tests\nexport const createLabeledEventToTriggerMap = (triggers: Trigger[]) => {\n  const labeledEventToTriggerMap = new Map<string, Trigger[]>();\n  for (const trigger of triggers) {\n    for (const condition of trigger.conditions) {\n      if (condition.type === 'LABELED_EVENT') {\n        const eventId = condition.match.eventId;\n        // Get existing triggers for this event ID or initialize empty array\n        let existingTriggers = labeledEventToTriggerMap.get(eventId);\n        if (!existingTriggers) {\n          existingTriggers = [];\n          labeledEventToTriggerMap.set(eventId, existingTriggers);\n        }\n        // Add current trigger to the list of triggers for this event ID\n        existingTriggers.push(trigger);\n      }\n    }\n  }\n  return labeledEventToTriggerMap;\n};\n\n/**\n * Matches an event to labeled events based on the event's properties.\n * The logic matches exactly what is supported by the query backend.\n * TODO: later pre-filter the labeled events based on URL first\n *\n * @param event - The event to match against labeled events\n * @param labeledEvents - Array of labeled events to match against\n * @returns Array of matching labeled events\n */\nexport const matchEventToLabeledEvents = (\n  event: ElementBasedTimestampedEvent<ElementBasedEvent>,\n  labeledEvents: LabeledEvent[],\n) => {\n  return labeledEvents.filter((le) => {\n    return le.definition.some((def) => {\n      return (\n        eventTypeToBrowserEventMap[def.event_type] === event.type &&\n        def.filters.every((filter) => matchEventToFilter(event, filter))\n      );\n    });\n  });\n};\n\nexport const matchLabeledEventsToTriggers = (labeledEvents: LabeledEvent[], leToTriggerMap: Map<string, Trigger[]>) => {\n  const matchingTriggers = new Set<Trigger>();\n  for (const le of labeledEvents) {\n    const triggers = leToTriggerMap.get(le.id);\n    if (triggers) {\n      for (const trigger of triggers) {\n        matchingTriggers.add(trigger);\n      }\n    }\n  }\n  return Array.from(matchingTriggers);\n};\n\nexport class TriggerEvaluator {\n  constructor(\n    private groupedLabeledEvents: ReturnType<typeof groupLabeledEventIdsByEventType>,\n    private labeledEventToTriggerMap: ReturnType<typeof createLabeledEventToTriggerMap>,\n    private dataExtractor: DataExtractor,\n    private options: ElementInteractionsOptions,\n  ) {}\n\n  evaluate(event: ElementBasedTimestampedEvent<ElementBasedEvent>) {\n    // If there is no pageActions, return the event as is\n    const { pageActions } = this.options;\n    if (!pageActions) {\n      return event;\n    }\n\n    // Find matching labeled events\n    const matchingLabeledEvents = matchEventToLabeledEvents(\n      event,\n      Array.from(this.groupedLabeledEvents[event.type]).map((id) => pageActions.labeledEvents[id]),\n    );\n    // Find matching conditions\n    const matchingTriggers = matchLabeledEventsToTriggers(matchingLabeledEvents, this.labeledEventToTriggerMap);\n    for (const trigger of matchingTriggers) {\n      executeActions(trigger.actions, event, this.dataExtractor);\n    }\n\n    return event;\n  }\n\n  update(\n    groupedLabeledEvents: ReturnType<typeof groupLabeledEventIdsByEventType>,\n    labeledEventToTriggerMap: ReturnType<typeof createLabeledEventToTriggerMap>,\n    options: ElementInteractionsOptions,\n  ) {\n    this.groupedLabeledEvents = groupedLabeledEvents;\n    this.labeledEventToTriggerMap = labeledEventToTriggerMap;\n    this.options = options;\n  }\n}\n\nexport const createTriggerEvaluator = (\n  groupedLabeledEvents: ReturnType<typeof groupLabeledEventIdsByEventType>,\n  labeledEventToTriggerMap: ReturnType<typeof createLabeledEventToTriggerMap>,\n  dataExtractor: DataExtractor,\n  options: ElementInteractionsOptions,\n) => {\n  return new TriggerEvaluator(groupedLabeledEvents, labeledEventToTriggerMap, dataExtractor, options);\n};\n"]}