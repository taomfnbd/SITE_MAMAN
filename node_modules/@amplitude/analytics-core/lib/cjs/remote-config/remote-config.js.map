{"version":3,"file":"remote-config.js","sourceRoot":"","sources":["../../../src/remote-config/remote-config.ts"],"names":[],"mappings":"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","sourcesContent":["import { ServerZoneType } from '../types/server-zone';\nimport { ILogger } from '../logger';\nimport { RemoteConfigLocalStorage } from './remote-config-localstorage';\nimport { UUID } from '../utils/uuid';\n\n/**\n * Modes for receiving remote config updates:\n * - `'all'` – Optimized for both speed and freshness. Returns the fastest response first\n *   (cache or remote), then always waits for and returns the remote response to ensure\n *   the most up-to-date config. Callback may be called once (if remote wins) or twice\n *   (cache first, then remote).\n * - `{ timeout: number }` – Prefers remote data but with a fallback strategy. Waits for\n *   a remote response until the specified timeout (in milliseconds), then falls back to\n *   cached data if available. Callback is called exactly once.\n */\nexport type DeliveryMode = 'all' | { timeout: number };\n\n/**\n * Sources of returned remote config:\n * - `cache` - Fetched from local storage.\n * - `remote` - Fetched from remote.\n */\nexport type Source = 'cache' | 'remote';\n\nexport const US_SERVER_URL = 'https://sr-client-cfg.amplitude.com/config';\nexport const EU_SERVER_URL = 'https://sr-client-cfg.eu.amplitude.com/config';\nexport const DEFAULT_MAX_RETRIES = 3;\n\n/**\n * The default timeout for fetch in milliseconds.\n * Linear backoff policy: timeout / retry times is the interval between fetch retry.\n */\nconst DEFAULT_TIMEOUT = 1000;\n\n/**\n * The minimum time between fetches in milliseconds.\n * This prevents too many requests from being sent in a short period of time.\n */\nconst DEFAULT_MIN_TIME_BETWEEN_FETCHES = 5 * 60 * 1000; // 5 minutes\n\nexport interface RemoteConfig {\n  [key: string]: any;\n}\n\nexport interface RemoteConfigInfo {\n  remoteConfig: RemoteConfig | null;\n  // Timestamp of when the remote config was fetched.\n  lastFetch: Date;\n}\n\nexport interface RemoteConfigStorage {\n  /**\n   * Fetch remote config from storage asynchronously.\n   */\n  fetchConfig(): Promise<RemoteConfigInfo>;\n\n  /**\n   * Set remote config to storage asynchronously.\n   */\n  setConfig(config: RemoteConfigInfo): Promise<boolean>;\n}\n\n/**\n * Information about each callback registered by `RemoteConfigClient.subscribe()`,\n * managed internally by `RemoteConfigClient`.\n */\nexport interface CallbackInfo {\n  id: string;\n  key?: string;\n  deliveryMode: DeliveryMode;\n  callback: RemoteConfigCallback;\n  lastCallback?: Date;\n}\n\n/**\n * Callback used in `RemoteConfigClient.subscribe()`.\n * This function is called when the remote config is fetched.\n */\ntype RemoteConfigCallback = (remoteConfig: RemoteConfig | null, source: Source, lastFetch: Date) => void;\n\nexport interface IRemoteConfigClient {\n  /**\n   * Subscribe for updates to remote config.\n   * Callback is guaranteed to be called at least once,\n   * Whether we are able to fetch a config or not.\n   *\n   * @param key - a string containing a series of period delimited keys to filter the returned config.\n   * Ie, {a: {b: {c: ...}}} would return {b: {c: ...}} for \"a\" or {c: ...} for \"a.b\".\n   * Set to `undefined` to subscribe all keys.\n   * @param deliveryMode - how the initial callback is sent.\n   * @param callback - a block that will be called when remote config is fetched.\n   * @return id - identification of the subscribe and can be used to unsubscribe from updates.\n   */\n  subscribe(key: string | undefined, deliveryMode: DeliveryMode, callback: RemoteConfigCallback): string;\n\n  /**\n   * Unsubscribe a callback from receiving future updates.\n   *\n   * @param id - identification of the callback that you want to unsubscribe.\n   * It's the return value of subscribe().\n   * @return boolean - whether the callback is removed.\n   */\n  unsubscribe(id: string): boolean;\n\n  /**\n   * Request the remote config client to fetch from remote, update cache, and callback.\n   */\n  updateConfigs(): void;\n}\n\nexport class RemoteConfigClient implements IRemoteConfigClient {\n  static readonly CONFIG_GROUP = 'browser';\n\n  readonly apiKey: string;\n  readonly serverUrl: string;\n  readonly logger: ILogger;\n  readonly storage: RemoteConfigStorage;\n  // Registered callbackInfos by subscribe().\n  callbackInfos: CallbackInfo[] = [];\n  // Track the last successful fetch time for throttling (timestamp in milliseconds).\n  lastSuccessfulFetch: number | null = null;\n  // Store the in-flight fetch promise for deduplication.\n  fetchPromise: Promise<RemoteConfigInfo> | null = null;\n\n  constructor(apiKey: string, logger: ILogger, serverZone: ServerZoneType = 'US', serverUrl?: string) {\n    this.apiKey = apiKey;\n    this.serverUrl = serverUrl || (serverZone === 'US' ? US_SERVER_URL : EU_SERVER_URL);\n    this.logger = logger;\n    this.storage = new RemoteConfigLocalStorage(apiKey, logger);\n  }\n\n  subscribe(key: string | undefined, deliveryMode: DeliveryMode, callback: RemoteConfigCallback): string {\n    const id = UUID();\n    const callbackInfo = {\n      id: id,\n      key: key,\n      deliveryMode: deliveryMode,\n      callback: callback,\n    };\n    this.callbackInfos.push(callbackInfo);\n\n    if (deliveryMode === 'all') {\n      void this.subscribeAll(callbackInfo);\n    } else {\n      void this.subscribeWaitForRemote(callbackInfo, deliveryMode.timeout);\n    }\n\n    return id;\n  }\n\n  unsubscribe(id: string): boolean {\n    const index = this.callbackInfos.findIndex((callbackInfo) => callbackInfo.id === id);\n    if (index === -1) {\n      this.logger.debug(`Remote config client unsubscribe failed because callback with id ${id} doesn't exist.`);\n      return false;\n    }\n\n    this.callbackInfos.splice(index, 1);\n    this.logger.debug(`Remote config client unsubscribe succeeded removing callback with id ${id}.`);\n    return true;\n  }\n\n  async updateConfigs() {\n    // Check if we need to throttle based on last successful fetch time\n    if (this.lastSuccessfulFetch) {\n      const timeSinceLastFetch = Date.now() - this.lastSuccessfulFetch;\n      if (timeSinceLastFetch < DEFAULT_MIN_TIME_BETWEEN_FETCHES) {\n        this.logger.debug('Remote config client skipping updateConfigs: Too recent');\n        return;\n      }\n    }\n\n    const result = await this.getOrCreateFetchPromise();\n    void this.storage.setConfig(result);\n    this.callbackInfos.forEach((callbackInfo) => {\n      this.sendCallback(callbackInfo, result, 'remote');\n    });\n  }\n\n  /**\n   * Get the in-flight fetch promise or create a new one.\n   * This ensures multiple subscribe calls share the same network request.\n   */\n  getOrCreateFetchPromise(): Promise<RemoteConfigInfo> {\n    if (this.fetchPromise) {\n      return this.fetchPromise;\n    }\n\n    this.fetchPromise = this.fetch()\n      .then((result) => {\n        // Update last successful fetch time if we got a valid config\n        if (result.remoteConfig !== null) {\n          this.lastSuccessfulFetch = Date.now();\n        }\n        return result;\n      })\n      .finally(() => {\n        // Clear the promise after it settles (success or failure)\n        this.fetchPromise = null;\n      });\n\n    return this.fetchPromise;\n  }\n\n  /**\n   * Send remote first. If it's already complete, we can skip the cached response.\n   * - if remote is fetched first, no cache fetch.\n   * - if cache is fetched first, still fetching remote.\n   */\n  async subscribeAll(callbackInfo: CallbackInfo) {\n    const remotePromise = this.getOrCreateFetchPromise().then((result) => {\n      this.logger.debug(`Remote config client subscription all mode fetched from remote: ${JSON.stringify(result)}`);\n      this.sendCallback(callbackInfo, result, 'remote');\n      void this.storage.setConfig(result);\n    });\n\n    const cachePromise = this.storage.fetchConfig().then((result) => {\n      return result;\n    });\n\n    // Wait for the first result to resolve\n    const result = await Promise.race([remotePromise, cachePromise]);\n\n    // If cache is fetched first, wait for remote.\n    if (result !== undefined) {\n      this.logger.debug(`Remote config client subscription all mode fetched from cache: ${JSON.stringify(result)}`);\n      // Skip sending callback if cache is empty (first time user).\n      if (result.remoteConfig !== null) {\n        this.sendCallback(callbackInfo, result, 'cache');\n      } else {\n        this.logger.debug('Remote config client skips sending callback because cache is empty (first time user).');\n      }\n    }\n    await remotePromise;\n  }\n\n  /**\n   * Waits for a remote response until the given timeout, then return a cached copy, if available.\n   */\n  async subscribeWaitForRemote(callbackInfo: CallbackInfo, timeout: number) {\n    const timeoutPromise = new Promise((_, reject) => {\n      setTimeout(() => {\n        reject('Timeout exceeded');\n      }, timeout);\n    });\n\n    try {\n      const result: RemoteConfigInfo = (await Promise.race([\n        this.getOrCreateFetchPromise(),\n        timeoutPromise,\n      ])) as RemoteConfigInfo;\n\n      this.logger.debug('Remote config client subscription wait for remote mode returns from remote.');\n      this.sendCallback(callbackInfo, result, 'remote');\n      void this.storage.setConfig(result);\n    } catch (error) {\n      this.logger.debug(\n        'Remote config client subscription wait for remote mode exceeded timeout. Try to fetch from cache.',\n      );\n      const result = await this.storage.fetchConfig();\n      if (result.remoteConfig !== null) {\n        this.logger.debug('Remote config client subscription wait for remote mode returns a cached copy.');\n        this.sendCallback(callbackInfo, result, 'cache');\n      } else {\n        this.logger.debug('Remote config client subscription wait for remote mode failed to fetch cache.');\n        this.sendCallback(callbackInfo, result, 'remote');\n      }\n    }\n  }\n\n  /**\n   * Call the callback with filtered remote config based on key.\n   * @param remoteConfigInfo - the whole remote config object without filtering by key.\n   */\n  sendCallback(callbackInfo: CallbackInfo, remoteConfigInfo: RemoteConfigInfo, source: Source) {\n    callbackInfo.lastCallback = new Date();\n\n    let filteredConfig: RemoteConfig | null;\n    if (callbackInfo.key) {\n      // Filter remote config by key.\n      // For example, if remote config is {a: {b: {c: 1}}},\n      // if key = 'a', filter result is {b: {c: 1}};\n      // if key = 'a.b', filter result is {c: 1}\n      filteredConfig = callbackInfo.key.split('.').reduce((config, key) => {\n        if (config === null) {\n          return config;\n        }\n\n        return key in config ? (config[key] as RemoteConfig) : null;\n      }, remoteConfigInfo.remoteConfig);\n    } else {\n      filteredConfig = remoteConfigInfo.remoteConfig;\n    }\n\n    callbackInfo.callback(filteredConfig, source, remoteConfigInfo.lastFetch);\n  }\n\n  /**\n   * Fetch remote config from remote.\n   * @param retries - the number of retries. default is 3.\n   * @param timeout - the timeout in milliseconds. Default is 1000.\n   * This timeout serves two purposes:\n   * 1. It determines how long to wait for each remote config fetch request before aborting it.\n   *    If the fetch does not complete within the specified timeout, the request is cancelled using AbortController,\n   *    and the attempt is considered failed (and may be retried if retries remain).\n   * 2. It is also used to calculate the interval between retries. The total timeout is divided by the number of retries,\n   *    so each retry waits for (timeout / retries) milliseconds before the next attempt (linear backoff).\n   * @returns the remote config info. null if failed to fetch or the response is not valid JSON.\n   */\n  async fetch(retries: number = DEFAULT_MAX_RETRIES, timeout: number = DEFAULT_TIMEOUT): Promise<RemoteConfigInfo> {\n    const interval = timeout / retries;\n    const failedRemoteConfigInfo: RemoteConfigInfo = {\n      remoteConfig: null,\n      lastFetch: new Date(),\n    };\n\n    for (let attempt = 0; attempt < retries; attempt++) {\n      // Create AbortController for request timeout\n      const abortController = new AbortController();\n      const timeoutId = setTimeout(() => abortController.abort(), timeout);\n\n      try {\n        const res = await fetch(this.getUrlParams(), {\n          method: 'GET',\n          headers: {\n            Accept: '*/*',\n          },\n          signal: abortController.signal,\n        });\n\n        // Handle unsuccessful fetch\n        if (!res.ok) {\n          const body = await res.text();\n          this.logger.debug(`Remote config client fetch with retry time ${retries} failed with ${res.status}: ${body}`);\n        } else {\n          // Handle successful fetch\n          const remoteConfig: RemoteConfig = (await res.json()) as RemoteConfig;\n          return {\n            remoteConfig: remoteConfig,\n            lastFetch: new Date(),\n          };\n        }\n      } catch (error) {\n        // Handle rejects when the request fails, for example, a network error or timeout\n        if (error instanceof Error && error.name === 'AbortError') {\n          this.logger.debug(`Remote config client fetch with retry time ${retries} timed out after ${timeout}ms`);\n        } else {\n          this.logger.debug(`Remote config client fetch with retry time ${retries} is rejected because: `, error);\n        }\n      } finally {\n        // Clear the timeout since request completed or failed\n        clearTimeout(timeoutId);\n      }\n\n      // Linear backoff:\n      // wait for the specified interval before the next attempt\n      // except after the last attempt.\n      if (attempt < retries - 1) {\n        await new Promise((resolve) => setTimeout(resolve, this.getJitterDelay(interval)));\n      }\n    }\n\n    return failedRemoteConfigInfo;\n  }\n\n  /**\n   * Return jitter in the bound of [0,baseDelay) and then floor round.\n   */\n  getJitterDelay(baseDelay: number): number {\n    return Math.floor(Math.random() * baseDelay);\n  }\n\n  getUrlParams(): string {\n    // URL encode the API key to handle special characters\n    const encodedApiKey = encodeURIComponent(this.apiKey);\n\n    const urlParams = new URLSearchParams();\n    urlParams.append('config_group', RemoteConfigClient.CONFIG_GROUP);\n\n    return `${this.serverUrl}/${encodedApiKey}?${urlParams.toString()}`;\n  }\n}\n"]}