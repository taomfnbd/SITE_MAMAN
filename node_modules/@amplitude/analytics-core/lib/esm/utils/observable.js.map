{"version":3,"file":"observable.js","sourceRoot":"","sources":["../../../src/utils/observable.ts"],"names":[],"mappings":"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","sourcesContent":["export { Observable } from 'zen-observable-ts';\n\nimport { Observable as ZenObservable, Observer, Subscription } from 'zen-observable-ts';\n\n/**\n * asyncMap operator for Zen Observable\n *\n * Maps each value emitted by the source Observable using an async function,\n * emitting the resolved values in the same order they arrive.\n */\nfunction asyncMap<T, R>(observable: ZenObservable<T>, fn: (value: T) => Promise<R>): ZenObservable<R> {\n  return new ZenObservable(\n    (observer: { next: (value: R) => void; error: (error: any) => void; complete: () => void }) => {\n      observable.subscribe({\n        next: (value: T) => {\n          fn(value)\n            .then((result: R) => {\n              return observer.next(result);\n            })\n            .catch((error: any) => observer.error(error));\n        },\n        error: (error: any) => {\n          observer.error(error);\n        },\n        complete: () => {\n          observer.complete();\n        },\n      });\n    },\n  );\n}\n\ntype Unsubscribable = {\n  unsubscribe: () => void;\n};\n\n/**\n * merge operator for Zen Observable\n *\n * Merges two observables into a single observable, emitting values from both sources in the order they arrive.\n * @param sourceA Observable to merge\n * @param sourceB Observable to merge\n * @returns Unsubscribable cleanup function\n */\nfunction merge<A, B>(sourceA: ZenObservable<A>, sourceB: ZenObservable<B>): ZenObservable<A | B> {\n  return new ZenObservable<A | B>((observer) => {\n    let closed = false;\n\n    const subscriptions: Set<Unsubscribable> = new Set();\n\n    const cleanup = (): void => {\n      closed = true;\n      for (const sub of subscriptions) {\n        try {\n          sub.unsubscribe();\n        } catch {\n          /* do nothing */\n        }\n      }\n      subscriptions.clear();\n    };\n\n    const subscribeTo = <T>(source: ZenObservable<T>) => {\n      const sub = source.subscribe({\n        next(value: T) {\n          if (!closed) observer.next(value as A | B);\n        },\n        error(err) {\n          if (!closed) {\n            closed = true;\n            observer.error(err);\n            cleanup();\n          }\n        },\n        complete() {\n          subscriptions.delete(sub);\n          if (!closed && subscriptions.size === 0) {\n            observer.complete();\n            cleanup();\n            closed = true;\n          }\n        },\n      });\n\n      subscriptions.add(sub);\n    };\n\n    subscribeTo(sourceA);\n    subscribeTo(sourceB);\n\n    return cleanup;\n  });\n}\n\n// function share() {\nfunction multicast<T>(source: ZenObservable<T>): ZenObservable<T> {\n  const observers: Set<Observer<T>> = new Set();\n  let subscription: Subscription | null = null;\n\n  function cleanup() {\n    /* istanbul ignore next */\n    subscription?.unsubscribe();\n    subscription = null;\n    observers.clear();\n  }\n\n  return new ZenObservable<T>((observer) => {\n    observers.add(observer);\n\n    if (subscription === null) {\n      subscription = source.subscribe({\n        next(value) {\n          for (const obs of observers) {\n            /* istanbul ignore next */\n            obs.next?.(value);\n          }\n        },\n        error(err) {\n          for (const obs of observers) {\n            /* istanbul ignore next */\n            obs.error?.(err);\n          }\n          cleanup();\n        },\n        complete() {\n          for (const obs of observers) {\n            /* istanbul ignore next */\n            obs.complete?.();\n          }\n          cleanup();\n        },\n      });\n    }\n\n    // Return unsubscribe function for this observer\n    return () => {\n      observers.delete(observer);\n\n      // If no observers left, unsubscribe from the source\n      if (observers.size === 0 && subscription) {\n        subscription.unsubscribe();\n        subscription = null;\n      }\n    };\n  });\n}\n\nexport { asyncMap, multicast, merge, Unsubscribable };\n"]}