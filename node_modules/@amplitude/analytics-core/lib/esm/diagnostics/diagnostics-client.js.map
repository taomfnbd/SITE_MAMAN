{"version":3,"file":"diagnostics-client.js","sourceRoot":"","sources":["../../../src/diagnostics/diagnostics-client.ts"],"names":[],"mappings":"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","sourcesContent":["import { ILogger } from '../logger';\nimport { DiagnosticsStorage, IDiagnosticsStorage } from './diagnostics-storage';\nimport { ServerZoneType } from '../types/server-zone';\nimport { getGlobalScope } from '../global-scope';\nimport { isTimestampInSampleTemp } from '../utils/sampling';\nimport { enableSdkErrorListeners } from './uncaught-sdk-errors';\n\nexport const SAVE_INTERVAL_MS = 1000; // 1 second\nexport const FLUSH_INTERVAL_MS = 5 * 60 * 1000; // 5 minutes\nexport const DIAGNOSTICS_US_SERVER_URL = 'https://diagnostics.prod.us-west-2.amplitude.com/v1/capture';\nexport const DIAGNOSTICS_EU_SERVER_URL = 'https://diagnostics.prod.eu-central-1.amplitude.com/v1/capture';\n\n// In-memory storage limits\nexport const MAX_MEMORY_STORAGE_COUNT = 10000; // for tags, counters, histograms separately\nexport const MAX_MEMORY_STORAGE_EVENTS_COUNT = 10;\n\n// === Core Data Types ===\n\n/**\n * Key-value pairs for environment/context information\n */\ntype DiagnosticsTags = Record<string, string>;\n\n/**\n * Numeric counters that can be incremented\n */\ntype DiagnosticsCounters = Record<string, number>;\n\n/**\n * Properties for diagnostic events\n */\ntype EventProperties = Record<string, any>;\n\n/**\n * Individual diagnostic event\n */\ninterface DiagnosticsEvent {\n  readonly event_name: string;\n  readonly time: number;\n  readonly event_properties: EventProperties;\n}\n\n/**\n * Computed histogram statistics for final payload\n */\ninterface HistogramResult {\n  readonly count: number;\n  readonly min: number;\n  readonly max: number;\n  readonly avg: number;\n}\n\n/**\n * Internal histogram statistics with sum for efficient incremental updates\n */\nexport interface HistogramStats {\n  count: number;\n  min: number;\n  max: number;\n  sum: number; // Used for avg calculation\n}\n\n/**\n * Collection of histogram results keyed by histogram name\n */\ntype DiagnosticsHistograms = Record<string, HistogramResult>;\n\n/**\n * Collection of histogram stats keyed by histogram name (internal use for memory + persistence storage)\n */\ntype DiagnosticsHistogramStats = Record<string, HistogramStats>;\n\n// === Payload Types ===\n\n/**\n * Complete diagnostics payload sent to backend\n */\ninterface FlushPayload {\n  readonly tags: DiagnosticsTags;\n  readonly histogram: DiagnosticsHistograms;\n  readonly counters: DiagnosticsCounters;\n  readonly events: readonly DiagnosticsEvent[];\n}\n\n/**\n * Amplitude Diagnostics Client\n *\n * A client for collecting and managing diagnostics data including tags, counters,\n * histograms, and events. Data is stored persistently using IndexedDB to survive browser restarts and offline scenarios.\n *\n * Key Features:\n * - IndexedDB storage\n * - Time-based persistent storage flush interval (5 minutes since last flush)\n * - 1 second time-based memory storage flush to persistent storage\n * - Histogram statistics calculation (min, max, avg)\n */\nexport interface IDiagnosticsClient {\n  /**\n   * Set or update a tag\n   *\n   * @example\n   * ```typescript\n   * // Set environment tags\n   * diagnostics.setTag('library', 'amplitude-typescript/2.0.0');\n   * diagnostics.setTag('user_agent', navigator.userAgent);\n   * ```\n   */\n  setTag(name: string, value: string): void;\n\n  /**\n   * Increment a counter. If doesn't exist, create a counter and set value to 1\n   *\n   * @example\n   * ```typescript\n   * // Track counters\n   * diagnostics.increment('analytics.fileNotFound');\n   * diagnostics.increment('network.retry', 3);\n   * ```\n   */\n  increment(name: string, size?: number): void;\n\n  /**\n   * Record a histogram value\n   *\n   * @example\n   * ```typescript\n   * // Record performance metrics\n   * diagnostics.recordHistogram('sr.time', 5.2);\n   * diagnostics.recordHistogram('network.latency', 150);\n   * ```\n   */\n  recordHistogram(name: string, value: number): void;\n\n  /**\n   * Record an event\n   *\n   * @example\n   * ```typescript\n   * // Record diagnostic events\n   * diagnostics.recordEvent('error', {\n   *   stack_trace: '...',\n   * });\n   * ```\n   */\n  recordEvent(name: string, properties: EventProperties): void;\n\n  // Flush storage\n  _flush(): void;\n\n  /**\n   * Sets the sample rate for diagnostics.\n   *\n   * @example\n   * ```typescript\n   * diagnostics.setSampleRate(0.5);\n   * ```\n   */\n  _setSampleRate(sampleRate: number): void;\n}\n\nexport class DiagnosticsClient implements IDiagnosticsClient {\n  storage?: IDiagnosticsStorage;\n  logger: ILogger;\n  serverUrl: string;\n  apiKey: string;\n  // Whether to track diagnostics data based on sample rate and enabled flag\n  shouldTrack: boolean;\n  config: {\n    enabled: boolean;\n    sampleRate: number;\n  };\n  /**\n   * The timestamp when the diagnostics client was initialized.\n   * Save in memory to keep lifecycle sample rate calculation consistency.\n   */\n  startTimestamp: number;\n\n  // In-memory storages\n  inMemoryTags: DiagnosticsTags = {};\n  inMemoryCounters: DiagnosticsCounters = {};\n  inMemoryHistograms: DiagnosticsHistogramStats = {};\n  inMemoryEvents: DiagnosticsEvent[] = [];\n\n  // Timer for 1-second persistence\n  saveTimer: ReturnType<typeof setTimeout> | null = null;\n  // Timer for flush interval\n  flushTimer: ReturnType<typeof setTimeout> | null = null;\n\n  constructor(\n    apiKey: string,\n    logger: ILogger,\n    serverZone: ServerZoneType = 'US',\n    options?: {\n      enabled?: boolean;\n      sampleRate?: number;\n    },\n  ) {\n    this.apiKey = apiKey;\n    this.logger = logger;\n    this.serverUrl = serverZone === 'US' ? DIAGNOSTICS_US_SERVER_URL : DIAGNOSTICS_EU_SERVER_URL;\n\n    this.logger.debug('DiagnosticsClient: Initializing with options', JSON.stringify(options, null, 2));\n    // Diagnostics is enabled by default with sample rate of 0 (no sampling)\n    this.config = { enabled: true, sampleRate: 0, ...options };\n    this.startTimestamp = Date.now();\n    this.shouldTrack = isTimestampInSampleTemp(this.startTimestamp, this.config.sampleRate) && this.config.enabled;\n\n    if (DiagnosticsStorage.isSupported()) {\n      this.storage = new DiagnosticsStorage(apiKey, logger);\n    } else {\n      this.logger.debug('DiagnosticsClient: IndexedDB is not supported');\n    }\n\n    void this.initializeFlushInterval();\n\n    // Track internal diagnostics metrics for sampling\n    if (this.shouldTrack) {\n      this.increment('sdk.diagnostics.sampled.in.and.enabled');\n      enableSdkErrorListeners(this);\n    }\n  }\n\n  /**\n   * Check if storage is available and tracking is enabled\n   */\n  isStorageAndTrackEnabled(): boolean {\n    return Boolean(this.storage) && Boolean(this.shouldTrack);\n  }\n\n  setTag(name: string, value: string) {\n    if (!this.isStorageAndTrackEnabled()) {\n      return;\n    }\n\n    if (Object.keys(this.inMemoryTags).length >= MAX_MEMORY_STORAGE_COUNT) {\n      this.logger.debug('DiagnosticsClient: Early return setTags as reaching memory limit');\n      return;\n    }\n\n    this.inMemoryTags[name] = value;\n    this.startTimersIfNeeded();\n  }\n\n  increment(name: string, size = 1) {\n    if (!this.isStorageAndTrackEnabled()) {\n      return;\n    }\n\n    if (Object.keys(this.inMemoryCounters).length >= MAX_MEMORY_STORAGE_COUNT) {\n      this.logger.debug('DiagnosticsClient: Early return increment as reaching memory limit');\n      return;\n    }\n\n    this.inMemoryCounters[name] = (this.inMemoryCounters[name] || 0) + size;\n    this.startTimersIfNeeded();\n  }\n\n  recordHistogram(name: string, value: number) {\n    if (!this.isStorageAndTrackEnabled()) {\n      return;\n    }\n\n    if (Object.keys(this.inMemoryHistograms).length >= MAX_MEMORY_STORAGE_COUNT) {\n      this.logger.debug('DiagnosticsClient: Early return recordHistogram as reaching memory limit');\n      return;\n    }\n\n    const existing = this.inMemoryHistograms[name];\n    if (existing) {\n      // Update existing stats incrementally\n      existing.count += 1;\n      existing.min = Math.min(existing.min, value);\n      existing.max = Math.max(existing.max, value);\n      existing.sum += value;\n    } else {\n      // Create new stats\n      this.inMemoryHistograms[name] = {\n        count: 1,\n        min: value,\n        max: value,\n        sum: value,\n      };\n    }\n    this.startTimersIfNeeded();\n  }\n\n  recordEvent(name: string, properties: EventProperties) {\n    if (!this.isStorageAndTrackEnabled()) {\n      return;\n    }\n\n    if (this.inMemoryEvents.length >= MAX_MEMORY_STORAGE_EVENTS_COUNT) {\n      this.logger.debug('DiagnosticsClient: Early return recordEvent as reaching memory limit');\n      return;\n    }\n\n    this.inMemoryEvents.push({\n      event_name: name,\n      time: Date.now(),\n      event_properties: properties,\n    });\n    this.startTimersIfNeeded();\n  }\n\n  startTimersIfNeeded() {\n    if (!this.saveTimer) {\n      this.saveTimer = setTimeout(() => {\n        this.saveAllDataToStorage()\n          .catch((error) => {\n            this.logger.debug('DiagnosticsClient: Failed to save all data to storage', error);\n          })\n          .finally(() => {\n            this.saveTimer = null;\n          });\n      }, SAVE_INTERVAL_MS);\n    }\n\n    if (!this.flushTimer) {\n      this.flushTimer = setTimeout(() => {\n        this._flush()\n          .catch((error) => {\n            this.logger.debug('DiagnosticsClient: Failed to flush', error);\n          })\n          .finally(() => {\n            this.flushTimer = null;\n          });\n      }, FLUSH_INTERVAL_MS);\n    }\n  }\n\n  async saveAllDataToStorage() {\n    if (!this.storage) {\n      return;\n    }\n    const tagsToSave = { ...this.inMemoryTags };\n    const countersToSave = { ...this.inMemoryCounters };\n    const histogramsToSave = { ...this.inMemoryHistograms };\n    const eventsToSave = [...this.inMemoryEvents];\n\n    this.inMemoryEvents = [];\n    this.inMemoryTags = {};\n    this.inMemoryCounters = {};\n    this.inMemoryHistograms = {};\n\n    await Promise.all([\n      this.storage.setTags(tagsToSave),\n      this.storage.incrementCounters(countersToSave),\n      this.storage.setHistogramStats(histogramsToSave),\n      this.storage.addEventRecords(eventsToSave),\n    ]);\n  }\n\n  async _flush() {\n    if (!this.storage) {\n      return;\n    }\n\n    await this.saveAllDataToStorage();\n    this.saveTimer = null;\n    this.flushTimer = null;\n\n    // Get all data from storage and clear it\n    const {\n      tags: tagRecords,\n      counters: counterRecords,\n      histogramStats: histogramStatsRecords,\n      events: eventRecords,\n    } = await this.storage.getAllAndClear();\n\n    // Update the last flush timestamp\n    void this.storage.setLastFlushTimestamp(Date.now());\n\n    // Convert metrics to the expected format\n    const tags: DiagnosticsTags = {};\n    tagRecords.forEach((record) => {\n      tags[record.key] = record.value;\n    });\n\n    const counters: DiagnosticsCounters = {};\n    counterRecords.forEach((record) => {\n      counters[record.key] = record.value;\n    });\n\n    const histogram: DiagnosticsHistograms = {};\n    histogramStatsRecords.forEach((stats) => {\n      histogram[stats.key] = {\n        count: stats.count,\n        min: stats.min,\n        max: stats.max,\n        avg: Math.round((stats.sum / stats.count) * 100) / 100, // round the average to 2 decimal places.\n      };\n    });\n\n    const events: DiagnosticsEvent[] = eventRecords.map((record) => ({\n      event_name: record.event_name,\n      time: record.time,\n      event_properties: record.event_properties,\n    }));\n\n    // Early return if all data collections are empty\n    if (Object.keys(counters).length === 0 && Object.keys(histogram).length === 0 && events.length === 0) {\n      return;\n    }\n\n    // Create flush payload\n    const payload: FlushPayload = {\n      tags,\n      histogram,\n      counters,\n      events,\n    };\n\n    // Send payload to diagnostics server\n    void this.fetch(payload);\n  }\n\n  /**\n   * Send diagnostics data to the server\n   */\n  async fetch(payload: FlushPayload) {\n    try {\n      if (!getGlobalScope()) {\n        throw new Error('DiagnosticsClient: Fetch is not supported');\n      }\n\n      const response = await fetch(this.serverUrl, {\n        method: 'POST',\n        headers: {\n          'X-ApiKey': this.apiKey,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(payload),\n      });\n\n      if (!response.ok) {\n        this.logger.debug('DiagnosticsClient: Failed to send diagnostics data.');\n        return;\n      }\n\n      this.logger.debug('DiagnosticsClient: Successfully sent diagnostics data');\n    } catch (error) {\n      this.logger.debug('DiagnosticsClient: Failed to send diagnostics data. ', error);\n    }\n  }\n\n  /**\n   * Initialize flush interval logic.\n   * Check if 5 minutes has passed since last flush, if so flush immediately.\n   * Otherwise set a timer to flush when the interval is reached.\n   */\n  async initializeFlushInterval() {\n    if (!this.storage) {\n      return;\n    }\n    const now = Date.now();\n    const lastFlushTimestamp = (await this.storage.getLastFlushTimestamp()) || -1;\n\n    // If last flush timestamp is -1, it means this is a new client\n    // Save current timestamp as the initial \"last flush timestamp\"\n    // and schedule the flush timer\n    if (lastFlushTimestamp === -1) {\n      void this.storage.setLastFlushTimestamp(now);\n      this._setFlushTimer(FLUSH_INTERVAL_MS);\n      return;\n    }\n\n    const timeSinceLastFlush = now - lastFlushTimestamp;\n    if (timeSinceLastFlush >= FLUSH_INTERVAL_MS) {\n      // More than 5 minutes has passed, flush immediately\n      void this._flush();\n      return;\n    } else {\n      // Set timer for remaining time\n      this._setFlushTimer(FLUSH_INTERVAL_MS - timeSinceLastFlush);\n    }\n  }\n\n  /**\n   * Helper method to set flush timer with consistent error handling\n   */\n  private _setFlushTimer(delay: number) {\n    this.flushTimer = setTimeout(() => {\n      this._flush()\n        .catch((error) => {\n          this.logger.debug('DiagnosticsClient: Failed to flush', error);\n        })\n        .finally(() => {\n          this.flushTimer = null;\n        });\n    }, delay);\n  }\n\n  _setSampleRate(sampleRate: number): void {\n    this.logger.debug('DiagnosticsClient: Setting sample rate to', sampleRate);\n    this.config.sampleRate = sampleRate;\n    this.shouldTrack = isTimestampInSampleTemp(this.startTimestamp, this.config.sampleRate) && this.config.enabled;\n    this.logger.debug('DiagnosticsClient: Should track is', this.shouldTrack);\n  }\n}\n"]}