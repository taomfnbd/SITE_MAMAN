{"version":3,"file":"xhr.js","sourceRoot":"","sources":["../../../src/transports/xhr.ts"],"names":[],"mappings":";;;;AAAA,4DAAwF;AAExF;IAAkC,wCAAa;IAM7C,sBAAY,aAA0C;QAA1C,8BAAA,EAAA,kBAA0C;QAAtD,YACE,iBAAO,SAER;QARO,WAAK,GAAG;YACd,IAAI,EAAE,CAAC;SACR,CAAC;QAKA,KAAI,CAAC,aAAa,GAAG,aAAa,CAAC;;IACrC,CAAC;IAEK,2BAAI,GAAV,UAAW,SAAiB,EAAE,OAAgB;;;;gBAC5C,sBAAO,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;;wBACjC,wBAAwB;wBACxB,IAAI,OAAO,cAAc,KAAK,WAAW,EAAE;4BACzC,MAAM,CAAC,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC,CAAC;yBACrD;wBAED,IAAM,GAAG,GAAG,IAAI,cAAc,EAAE,CAAC;wBACjC,GAAG,CAAC,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,IAAI,CAAC,CAAC;wBAClC,GAAG,CAAC,kBAAkB,GAAG;4BACvB,IAAI,GAAG,CAAC,UAAU,KAAK,KAAI,CAAC,KAAK,CAAC,IAAI,EAAE;gCACtC,IAAM,YAAY,GAAG,GAAG,CAAC,YAAY,CAAC;gCACtC,IAAI;oCACF,iEAAiE;oCACjE,OAAO,CAAC,KAAI,CAAC,aAAa,CAAC,IAAI,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,CAAC;iCACvD;gCAAC,WAAM;oCACN,OAAO,CAAC,KAAI,CAAC,aAAa,CAAC,EAAE,IAAI,EAAE,GAAG,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;iCACnD;6BACF;wBACH,CAAC,CAAC;wBACF,mFAAmF;wBACnF,IAAM,OAAO,sBACX,cAAc,EAAE,kBAAkB,EAClC,MAAM,EAAE,KAAK,IACV,KAAI,CAAC,aAAa,CACtB,CAAC;;4BACF,KAA2B,IAAA,KAAA,iBAAA,MAAM,CAAC,OAAO,CAAC,OAAO,CAAC,CAAA,gBAAA,4BAAE;gCAAzC,IAAA,KAAA,2BAAY,EAAX,GAAG,QAAA,EAAE,KAAK,QAAA;gCACpB,GAAG,CAAC,gBAAgB,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;6BAClC;;;;;;;;;wBACD,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;oBACpC,CAAC,CAAC,EAAC;;;KACJ;IACH,mBAAC;AAAD,CAAC,AA3CD,CAAkC,8BAAa,GA2C9C;AA3CY,oCAAY","sourcesContent":["import { BaseTransport, Payload, Response, Transport } from '@amplitude/analytics-core';\n\nexport class XHRTransport extends BaseTransport implements Transport {\n  private state = {\n    done: 4,\n  };\n  private customHeaders: Record<string, string>;\n\n  constructor(customHeaders: Record<string, string> = {}) {\n    super();\n    this.customHeaders = customHeaders;\n  }\n\n  async send(serverUrl: string, payload: Payload): Promise<Response | null> {\n    return new Promise((resolve, reject) => {\n      /* istanbul ignore if */\n      if (typeof XMLHttpRequest === 'undefined') {\n        reject(new Error('XHRTransport is not supported.'));\n      }\n\n      const xhr = new XMLHttpRequest();\n      xhr.open('POST', serverUrl, true);\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === this.state.done) {\n          const responseText = xhr.responseText;\n          try {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            resolve(this.buildResponse(JSON.parse(responseText)));\n          } catch {\n            resolve(this.buildResponse({ code: xhr.status }));\n          }\n        }\n      };\n      // Merge headers: custom headers override defaults (consistent with FetchTransport)\n      const headers: Record<string, string> = {\n        'Content-Type': 'application/json',\n        Accept: '*/*',\n        ...this.customHeaders,\n      };\n      for (const [key, value] of Object.entries(headers)) {\n        xhr.setRequestHeader(key, value);\n      }\n      xhr.send(JSON.stringify(payload));\n    });\n  }\n}\n"]}